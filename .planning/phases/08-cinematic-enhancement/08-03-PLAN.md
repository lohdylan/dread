---
phase: 08-cinematic-enhancement
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - src/client/java/com/dread/client/CinematicCompensationRenderer.java
  - src/client/java/com/dread/client/DeathCinematicClientHandler.java
  - src/client/java/com/dread/DreadClient.java
  - src/main/java/com/dread/death/DeathCinematicController.java
  - src/client/java/com/dread/client/CameraShakeHandler.java
autonomous: true

must_haves:
  truths:
    - "Red vignette + white flash boost when shake intensity reduced"
    - "Compensation only renders during cinematic, not downed state"
    - "Low FPS (<45) auto-reduces shake and triggers compensation"
    - "Cinematic duration matches 1.8s death_grab animation"
    - "Dread entity plays death_grab animation during cinematic"
  artifacts:
    - path: "src/client/java/com/dread/client/CinematicCompensationRenderer.java"
      provides: "Vignette and flash compensation when shake reduced"
      min_lines: 40
    - path: "src/client/java/com/dread/client/DeathCinematicClientHandler.java"
      provides: "Extended cinematic duration, triggers death_grab on entity"
      contains: "setPlayingDeathGrab"
    - path: "src/client/java/com/dread/client/CameraShakeHandler.java"
      provides: "FPS-based auto-reduction"
      contains: "getAdaptiveIntensity"
  key_links:
    - from: "DeathCinematicClientHandler.java"
      to: "CinematicCompensationRenderer.java"
      via: "getCompensationAmount() for rendering"
      pattern: "compensationAmount"
    - from: "DeathCinematicClientHandler.java"
      to: "DreadEntity.setPlayingDeathGrab()"
      via: "Entity animation trigger"
      pattern: "setPlayingDeathGrab"
---

<objective>
Add visual compensation effects for reduced shake, FPS-based auto-reduction, and synchronize cinematic duration with the new death_grab animation.

Purpose: Ensure players with reduced/disabled shake still experience horror impact through visual compensation, while preventing motion sickness at low FPS.

Output: CinematicCompensationRenderer, FPS auto-reduction in CameraShakeHandler, extended cinematic duration, animation trigger.
</objective>

<execution_context>
@C:\Users\dylan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dylan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-cinematic-enhancement/08-RESEARCH.md
@.planning/phases/08-cinematic-enhancement/08-CONTEXT.md
@.planning/phases/08-cinematic-enhancement/08-01-SUMMARY.md
@.planning/phases/08-cinematic-enhancement/08-02-SUMMARY.md
@src/client/java/com/dread/client/DeathCinematicClientHandler.java
@src/client/java/com/dread/client/CameraShakeHandler.java
@src/client/java/com/dread/client/CrawlVignetteRenderer.java
@src/client/java/com/dread/DreadClient.java
@src/main/java/com/dread/death/DeathCinematicController.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CinematicCompensationRenderer</name>
  <files>src/client/java/com/dread/client/CinematicCompensationRenderer.java</files>
  <action>
Create a new renderer class for visual compensation effects when camera shake is reduced. This boosts horror impact for motion-sensitive players.

Following the CrawlVignetteRenderer pattern:

```java
package com.dread.client;

import com.mojang.blaze3d.systems.RenderSystem;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.render.RenderTickCounter;
import net.minecraft.util.Identifier;

/**
 * Renders visual compensation effects during death cinematic when camera shake is reduced.
 * Boosts red vignette and adds white flash to maintain horror impact for motion-sensitive players.
 */
public class CinematicCompensationRenderer {

    private static final Identifier VIGNETTE_TEXTURE =
        Identifier.ofVanilla("textures/misc/vignette.png");

    // Track compensation amount (0.0 = full shake, 1.0 = no shake)
    private static float compensationAmount = 0.0f;
    private static boolean isActive = false;
    private static int flashTimer = 0;
    private static final int FLASH_DURATION = 2; // 0.1s pulse (2 ticks)

    /**
     * Register with HudRenderCallback during client initialization.
     */
    public static void register() {
        HudRenderCallback.EVENT.register(CinematicCompensationRenderer::render);
    }

    /**
     * Set compensation amount based on shake reduction.
     * Call from DeathCinematicClientHandler when shake starts.
     *
     * @param amount 0.0 (full shake, no compensation) to 1.0 (no shake, full compensation)
     */
    public static void setCompensation(float amount) {
        compensationAmount = Math.clamp(amount, 0.0f, 1.0f);
        isActive = amount > 0.0f;
        if (isActive) {
            flashTimer = FLASH_DURATION; // Start flash pulse
        }
    }

    /**
     * Stop rendering compensation (call when cinematic ends).
     */
    public static void stop() {
        compensationAmount = 0.0f;
        isActive = false;
        flashTimer = 0;
    }

    /**
     * Tick the flash timer.
     */
    public static void tick() {
        if (flashTimer > 0) {
            flashTimer--;
        }
    }

    /**
     * Render compensation effects.
     */
    private static void render(DrawContext context, RenderTickCounter tickCounter) {
        // Only render during active cinematic with compensation needed
        if (!isActive || compensationAmount <= 0.0f) {
            return;
        }

        // Don't render if downed state vignette is active (avoid stacking)
        if (DownedStateClientHandler.isDownedEffectActive()) {
            return;
        }

        MinecraftClient client = MinecraftClient.getInstance();
        int width = client.getWindow().getScaledWidth();
        int height = client.getWindow().getScaledHeight();

        RenderSystem.enableBlend();
        RenderSystem.defaultBlendFunc();

        // Boosted red vignette (more intense than normal)
        // Base opacity 0.4, boosted by up to 0.3 based on compensation
        float vignetteOpacity = 0.4f + (compensationAmount * 0.3f);
        RenderSystem.setShaderColor(1.0f, 0.15f, 0.15f, vignetteOpacity);
        context.drawTexture(
            VIGNETTE_TEXTURE,
            0, 0,
            0, 0,
            width, height,
            width, height
        );

        // White flash overlay (brief pulse at start)
        if (flashTimer > 0) {
            float flashOpacity = compensationAmount * 0.25f * (flashTimer / (float)FLASH_DURATION);
            // Draw white rectangle overlay
            int alpha = (int)(flashOpacity * 255);
            int color = (alpha << 24) | 0xFFFFFF; // ARGB white with alpha
            context.fill(0, 0, width, height, color);
        }

        RenderSystem.setShaderColor(1.0f, 1.0f, 1.0f, 1.0f);
        RenderSystem.disableBlend();
    }
}
```
  </action>
  <verify>
Verify CinematicCompensationRenderer.java exists with:
1. register() method for HudRenderCallback
2. setCompensation() method accepting 0.0-1.0 range
3. stop() method to disable rendering
4. tick() method for flash timer
5. render() method with vignette and flash effects
6. Guard against stacking with DownedStateClientHandler
  </verify>
  <done>
CinematicCompensationRenderer renders boosted red vignette and white flash when shake is reduced
  </done>
</task>

<task type="auto">
  <name>Task 2: Add FPS-based auto-reduction to CameraShakeHandler</name>
  <files>src/client/java/com/dread/client/CameraShakeHandler.java</files>
  <action>
Add a method to calculate adaptive intensity based on FPS, preventing judder at low frame rates.

Add this method to CameraShakeHandler:

```java
/**
 * Get adaptive shake intensity based on current FPS.
 * Reduces shake below 45 FPS to prevent judder.
 *
 * @param client Minecraft client for FPS detection
 * @param configIntensity Base intensity from config (0.0 to 1.0)
 * @return Adjusted intensity (may be lower than config if FPS is low)
 */
public float getAdaptiveIntensity(net.minecraft.client.MinecraftClient client, float configIntensity) {
    int fps = client.getCurrentFps();

    // Auto-reduce below 45 FPS to prevent judder
    float fpsMultiplier = 1.0f;
    if (fps < 45 && fps > 0) {
        // Smooth scaling: 30fps = 67%, 20fps = 44%, floor at 30%
        fpsMultiplier = Math.max(0.3f, fps / 45.0f);
    }

    return configIntensity * fpsMultiplier;
}

/**
 * Calculate compensation amount (inverse of final intensity).
 * Used to determine how much visual compensation to apply.
 *
 * @param configIntensity Original config intensity (0.0 to 1.0)
 * @param finalIntensity Actual intensity after FPS reduction (0.0 to 1.0)
 * @return Compensation amount (0.0 = no compensation, 1.0 = full compensation)
 */
public float getCompensationAmount(float configIntensity, float finalIntensity) {
    if (configIntensity <= 0.0f) {
        return 1.0f; // Full compensation if shake disabled
    }
    return 1.0f - (finalIntensity / configIntensity);
}
```

Also add import at top if not present:
```java
import net.minecraft.client.MinecraftClient;
```
  </action>
  <verify>
Verify CameraShakeHandler.java contains:
1. getAdaptiveIntensity() method with FPS check
2. getCompensationAmount() method
3. Threshold at 45 FPS
4. Floor multiplier at 0.3f
  </verify>
  <done>
CameraShakeHandler auto-reduces shake intensity at low FPS and calculates compensation amount
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate compensation and extend cinematic duration</name>
  <files>src/client/java/com/dread/client/DeathCinematicClientHandler.java</files>
  <action>
Update the cinematic handler to use FPS-adaptive intensity, trigger compensation effects, trigger entity animation, and match the new 1.8s duration.

1. Update the duration constant (top of class):
```java
private static final int CINEMATIC_DURATION_TICKS = 36; // 1.8 seconds (matches death_grab animation)
```

2. Update imports:
```java
import com.dread.entity.DreadEntity;
```

3. Update startCinematic() to use adaptive intensity and trigger compensation:
```java
public static void startCinematic(CinematicTriggerS2C payload) {
    MinecraftClient client = MinecraftClient.getInstance();
    if (client.player == null || client.world == null) {
        return;
    }

    // Store original camera entity (the player)
    originalCameraEntity = client.getCameraEntity();

    // Find Dread entity in world
    dreadEntityId = payload.dreadEntityId();
    Entity dreadEntity = client.world.getEntityById(dreadEntityId);

    if (dreadEntity != null) {
        // Lock camera onto Dread
        client.setCameraEntity(dreadEntity);

        // Trigger death_grab animation on entity
        if (dreadEntity instanceof DreadEntity dread) {
            dread.setPlayingDeathGrab(true);
        }

        // Calculate shake intensity with FPS adaptation
        var config = DreadConfigLoader.getConfig();
        float configIntensity = Math.clamp(config.cameraShakeIntensity, 0, 100) / 100.0f;
        float adaptiveIntensity = cameraShake.getAdaptiveIntensity(client, configIntensity);

        // Start shake with final intensity
        cameraShake.startShake(adaptiveIntensity);

        // Trigger compensation if shake was reduced
        float compensation = cameraShake.getCompensationAmount(configIntensity, adaptiveIntensity);
        if (compensation > 0.0f) {
            CinematicCompensationRenderer.setCompensation(compensation);
        }

        // Start cinematic timer
        cinematicActive = true;
        cinematicTimer = 0;
    }
}
```

4. Update tick() to also tick compensation:
```java
private static void tick() {
    cinematicTimer++;

    MinecraftClient client = MinecraftClient.getInstance();
    Entity cameraEntity = client.getCameraEntity();
    if (cameraEntity == null) return;

    // Update shake (deltaTime = 1 tick = 0.05 seconds)
    cameraShake.tick(0.05f);

    // Tick compensation flash timer
    CinematicCompensationRenderer.tick();

    // Apply shake offset to camera entity rotation
    if (cameraShake.isActive()) {
        float baseYaw = cameraEntity.getYaw();
        float basePitch = cameraEntity.getPitch();
        cameraEntity.setYaw(baseYaw + cameraShake.getYawOffset());
        cameraEntity.setPitch(basePitch + cameraShake.getPitchOffset());
    }

    if (cinematicTimer >= CINEMATIC_DURATION_TICKS) {
        endCinematic();
    }
}
```

5. Update endCinematic() to stop compensation and animation:
```java
private static void endCinematic() {
    MinecraftClient client = MinecraftClient.getInstance();

    // Reset shake and compensation
    cameraShake.reset();
    CinematicCompensationRenderer.stop();

    // Stop death_grab animation on entity
    if (client.world != null && dreadEntityId != -1) {
        Entity entity = client.world.getEntityById(dreadEntityId);
        if (entity instanceof DreadEntity dread) {
            dread.setPlayingDeathGrab(false);
        }
    }

    // Restore camera to original entity (player)
    if (originalCameraEntity != null) {
        client.setCameraEntity(originalCameraEntity);
        originalCameraEntity = null;
    }

    // Apply downed state effects
    DownedStateClientHandler.applyDownedEffects();

    // Reset cinematic state
    cinematicActive = false;
    cinematicTimer = 0;
    dreadEntityId = -1;
}
```
  </action>
  <verify>
Verify DeathCinematicClientHandler.java:
1. CINEMATIC_DURATION_TICKS is 36 (1.8 seconds)
2. startCinematic() triggers setPlayingDeathGrab(true)
3. startCinematic() uses getAdaptiveIntensity() and sets compensation
4. tick() calls CinematicCompensationRenderer.tick()
5. endCinematic() calls CinematicCompensationRenderer.stop()
6. endCinematic() sets setPlayingDeathGrab(false)
  </verify>
  <done>
Cinematic handler uses adaptive intensity, triggers compensation, controls entity animation, and has 1.8s duration
  </done>
</task>

<task type="auto">
  <name>Task 4: Register CinematicCompensationRenderer in DreadClient</name>
  <files>src/client/java/com/dread/DreadClient.java</files>
  <action>
Register the new compensation renderer during client initialization.

Add after the existing CrawlVignetteRenderer registration:

```java
// Register cinematic compensation renderer
CinematicCompensationRenderer.register();
```

Add import at top:
```java
import com.dread.client.CinematicCompensationRenderer;
```
  </action>
  <verify>
Verify DreadClient.java contains:
1. Import for CinematicCompensationRenderer
2. CinematicCompensationRenderer.register() call
  </verify>
  <done>
CinematicCompensationRenderer registered and will render during HUD callbacks
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build the project:
```bash
export JAVA_HOME="X:/Vibe Coding/jdk-21.0.6+7" && ./gradlew build
```

2. Verify all classes compile without errors

3. Trace the flow:
   - startCinematic() -> getAdaptiveIntensity() -> startShake() -> setCompensation()
   - tick() -> cameraShake.tick() -> CinematicCompensationRenderer.tick()
   - endCinematic() -> reset() -> stop() -> setPlayingDeathGrab(false)

4. Verify cinematic duration matches animation (36 ticks = 1.8s)
</verification>

<success_criteria>
- Build succeeds without errors
- CinematicCompensationRenderer exists and is registered
- CameraShakeHandler has FPS-based auto-reduction
- Cinematic duration is 36 ticks (1.8s)
- Entity animation is triggered via setPlayingDeathGrab()
- Compensation effects activate when shake is reduced
- All effects properly reset when cinematic ends
</success_criteria>

<output>
After completion, create `.planning/phases/08-cinematic-enhancement/08-03-SUMMARY.md`
</output>

---
phase: 03-death-revival-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/com/dread/death/DownedPlayersState.java
  - src/main/java/com/dread/death/DownedPlayerData.java
  - src/main/java/com/dread/death/RevivalProgress.java
autonomous: true

must_haves:
  truths:
    - "Downed players are tracked persistently in world data"
    - "Revival progress is tracked server-side with timing"
    - "State persists across world saves and server restarts"
  artifacts:
    - path: "src/main/java/com/dread/death/DownedPlayersState.java"
      provides: "Persistent world state for downed players"
      exports: ["getOrCreate", "setDowned", "isDowned", "decrementTimer", "removeDowned"]
    - path: "src/main/java/com/dread/death/DownedPlayerData.java"
      provides: "Per-player downed state data"
      exports: ["playerId", "remainingTicks", "downedPos"]
    - path: "src/main/java/com/dread/death/RevivalProgress.java"
      provides: "Revival attempt tracking"
      exports: ["downedPlayerId", "reviverPlayerId", "remainingTicks"]
  key_links:
    - from: "DownedPlayersState"
      to: "PersistentState"
      via: "extends"
      pattern: "extends PersistentState"
    - from: "DownedPlayersState"
      to: "world.getPersistentStateManager()"
      via: "getOrCreate() method"
      pattern: "getPersistentStateManager\\(\\)\\.getOrCreate"
---

<objective>
Create server-side persistent state for tracking downed players, countdown timers, and revival progress.

Purpose: Provide authoritative server-side state management for the death/revival system, following the established SpawnProbabilityState pattern.

Output:
- DownedPlayersState with NBT persistence
- Methods for downed state management (setDowned, isDowned, decrementTimer, removeDowned)
- Revival progress tracking (start, update, complete, cancel)
</objective>

<execution_context>
@C:\Users\dylan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dylan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-death-revival-system/03-RESEARCH.md

# Pattern reference
@src/main/java/com/dread/spawn/SpawnProbabilityState.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DownedPlayerData and RevivalProgress data classes</name>
  <files>
    src/main/java/com/dread/death/DownedPlayerData.java
    src/main/java/com/dread/death/RevivalProgress.java
  </files>
  <action>
    1. Create death package under src/main/java/com/dread/death/

    2. Create DownedPlayerData.java - stores per-player downed state:
       ```java
       package com.dread.death;

       import net.minecraft.nbt.NbtCompound;
       import net.minecraft.util.math.BlockPos;
       import java.util.UUID;

       /**
        * Tracks a single player's downed state.
        */
       public class DownedPlayerData {
           public final UUID playerId;
           public BlockPos downedPos;
           public int remainingTicks;  // 300 seconds = 6000 ticks

           public DownedPlayerData(UUID playerId, BlockPos downedPos, int remainingTicks) {
               this.playerId = playerId;
               this.downedPos = downedPos;
               this.remainingTicks = remainingTicks;
           }

           public DownedPlayerData(NbtCompound nbt) {
               this.playerId = nbt.getUuid("PlayerId");
               this.downedPos = BlockPos.fromLong(nbt.getLong("DownedPos"));
               this.remainingTicks = nbt.getInt("RemainingTicks");
           }

           public NbtCompound toNbt() {
               NbtCompound nbt = new NbtCompound();
               nbt.putUuid("PlayerId", playerId);
               nbt.putLong("DownedPos", downedPos.asLong());
               nbt.putInt("RemainingTicks", remainingTicks);
               return nbt;
           }

           public int getRemainingSeconds() {
               return remainingTicks / 20;
           }
       }
       ```

    3. Create RevivalProgress.java - tracks active revival attempts:
       ```java
       package com.dread.death;

       import java.util.UUID;

       /**
        * Tracks an active revival attempt.
        * Revival is uninterruptible once started (per CONTEXT.md decision).
        */
       public class RevivalProgress {
           public final UUID downedPlayerId;
           public final UUID reviverPlayerId;
           public int remainingTicks;  // 3 seconds = 60 ticks

           public static final int REVIVAL_DURATION_TICKS = 60;  // 3 seconds

           public RevivalProgress(UUID downedPlayerId, UUID reviverPlayerId) {
               this.downedPlayerId = downedPlayerId;
               this.reviverPlayerId = reviverPlayerId;
               this.remainingTicks = REVIVAL_DURATION_TICKS;
           }

           public float getProgress() {
               // 0.0 = just started, 1.0 = complete
               return 1.0f - ((float) remainingTicks / REVIVAL_DURATION_TICKS);
           }

           public boolean isComplete() {
               return remainingTicks <= 0;
           }

           public void tick() {
               if (remainingTicks > 0) {
                   remainingTicks--;
               }
           }
       }
       ```
  </action>
  <verify>
    Verify both classes compile with `./gradlew compileJava`.
  </verify>
  <done>
    - DownedPlayerData class created with NBT serialization
    - RevivalProgress class created with progress tracking
    - Both classes in death package
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DownedPlayersState persistent world data</name>
  <files>
    src/main/java/com/dread/death/DownedPlayersState.java
  </files>
  <action>
    Create DownedPlayersState.java following SpawnProbabilityState pattern:

    ```java
    package com.dread.death;

    import net.minecraft.nbt.NbtCompound;
    import net.minecraft.nbt.NbtList;
    import net.minecraft.registry.RegistryWrapper;
    import net.minecraft.server.network.ServerPlayerEntity;
    import net.minecraft.server.world.ServerWorld;
    import net.minecraft.util.math.BlockPos;
    import net.minecraft.world.PersistentState;

    import java.util.*;

    /**
     * Persistent state tracking all downed players in a world.
     * Handles countdown timers, revival progress, and spectator transitions.
     */
    public class DownedPlayersState extends PersistentState {

        private static final String STATE_NAME = "dread_downed_players";
        private static final int DOWNED_DURATION_TICKS = 300 * 20;  // 300 seconds

        private final Map<UUID, DownedPlayerData> downedPlayers = new HashMap<>();
        private final Map<UUID, RevivalProgress> activeRevivals = new HashMap<>();

        public DownedPlayersState() {
            super();
        }

        public static DownedPlayersState getOrCreate(ServerWorld world) {
            return world.getPersistentStateManager().getOrCreate(
                new Type<>(
                    DownedPlayersState::new,
                    DownedPlayersState::createFromNbt,
                    null
                ),
                STATE_NAME
            );
        }

        public static DownedPlayersState createFromNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {
            DownedPlayersState state = new DownedPlayersState();

            NbtList downedList = nbt.getList("DownedPlayers", 10);  // 10 = Compound type
            for (int i = 0; i < downedList.size(); i++) {
                NbtCompound playerNbt = downedList.getCompound(i);
                DownedPlayerData data = new DownedPlayerData(playerNbt);
                state.downedPlayers.put(data.playerId, data);
            }

            // Note: activeRevivals are not persisted - they reset on server restart
            return state;
        }

        @Override
        public NbtCompound writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {
            NbtList downedList = new NbtList();
            for (DownedPlayerData data : downedPlayers.values()) {
                downedList.add(data.toNbt());
            }
            nbt.put("DownedPlayers", downedList);
            return nbt;
        }

        // --- Downed State Management ---

        public void setDowned(ServerPlayerEntity player) {
            UUID playerId = player.getUuid();
            BlockPos pos = player.getBlockPos();
            downedPlayers.put(playerId, new DownedPlayerData(playerId, pos, DOWNED_DURATION_TICKS));
            markDirty();
        }

        public boolean isDowned(UUID playerId) {
            return downedPlayers.containsKey(playerId);
        }

        public boolean isDowned(ServerPlayerEntity player) {
            return isDowned(player.getUuid());
        }

        public DownedPlayerData getDownedData(UUID playerId) {
            return downedPlayers.get(playerId);
        }

        /**
         * Decrement timer for a downed player.
         * @return remaining seconds, or -1 if player not downed
         */
        public int decrementTimer(UUID playerId) {
            DownedPlayerData data = downedPlayers.get(playerId);
            if (data == null) return -1;

            data.remainingTicks--;
            markDirty();
            return data.getRemainingSeconds();
        }

        public void removeDowned(UUID playerId) {
            downedPlayers.remove(playerId);
            activeRevivals.remove(playerId);  // Cancel any revival in progress
            markDirty();
        }

        public Collection<DownedPlayerData> getAllDowned() {
            return Collections.unmodifiableCollection(downedPlayers.values());
        }

        // --- Revival Management ---

        public void startRevival(UUID downedPlayerId, UUID reviverPlayerId) {
            if (!isDowned(downedPlayerId)) return;

            activeRevivals.put(downedPlayerId, new RevivalProgress(downedPlayerId, reviverPlayerId));
            // Note: Revivals are uninterruptible per CONTEXT.md - no cancel on damage/movement
        }

        public boolean isBeingRevived(UUID downedPlayerId) {
            return activeRevivals.containsKey(downedPlayerId);
        }

        public RevivalProgress getRevivalProgress(UUID downedPlayerId) {
            return activeRevivals.get(downedPlayerId);
        }

        /**
         * Tick all active revivals.
         * @return List of player IDs whose revival just completed
         */
        public List<UUID> tickRevivals() {
            List<UUID> completed = new ArrayList<>();

            Iterator<Map.Entry<UUID, RevivalProgress>> iter = activeRevivals.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<UUID, RevivalProgress> entry = iter.next();
                RevivalProgress revival = entry.getValue();
                revival.tick();

                if (revival.isComplete()) {
                    completed.add(entry.getKey());
                    iter.remove();
                }
            }

            return completed;
        }

        public void cancelRevival(UUID downedPlayerId) {
            activeRevivals.remove(downedPlayerId);
        }
    }
    ```
  </action>
  <verify>
    Run `./gradlew build` to verify class compiles and integrates with Minecraft's PersistentState API.
  </verify>
  <done>
    - DownedPlayersState extends PersistentState
    - NBT serialization for persistence across saves
    - Downed state management methods implemented
    - Revival progress tracking implemented
    - Build succeeds
  </done>
</task>

</tasks>

<verification>
1. Run `JAVA_HOME="X:/Vibe Coding/jdk-21.0.6+7" ./gradlew build`
2. Verify all three classes compile without errors
3. Verify DownedPlayersState follows SpawnProbabilityState pattern for NBT serialization
</verification>

<success_criteria>
- DownedPlayerData, RevivalProgress, and DownedPlayersState classes exist
- State persists to NBT with proper serialization/deserialization
- Revival progress is uninterruptible (per CONTEXT.md decision)
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-death-revival-system/03-02-SUMMARY.md`
</output>

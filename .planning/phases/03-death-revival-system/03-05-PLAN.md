---
phase: 03-death-revival-system
plan: 05
type: execute
wave: 3
depends_on: ["03-03", "03-04"]
files_modified:
  - src/main/java/com/dread/death/DreadDeathManager.java
  - src/main/java/com/dread/death/RevivalInteractionHandler.java
  - src/main/java/com/dread/DreadMod.java
  - src/client/java/com/dread/client/RevivalProgressRenderer.java
  - src/client/java/com/dread/DreadClient.java
autonomous: true

must_haves:
  truths:
    - "Nearby player can crouch to initiate revival"
    - "Revival takes 3 seconds and is uninterruptible"
    - "Progress bar appears above downed player during revival"
    - "Timer expiration transitions player to spectator mode"
    - "Spectators can see Dread entity when living players cannot"
    - "Solo players experience permanent death stakes"
  artifacts:
    - path: "src/main/java/com/dread/death/DreadDeathManager.java"
      provides: "Central coordinator for death/revival tick processing"
      exports: ["register", "tick"]
    - path: "src/main/java/com/dread/death/RevivalInteractionHandler.java"
      provides: "Proximity-based revival detection and processing"
      exports: ["checkForRevivers", "completeRevival"]
    - path: "src/client/java/com/dread/client/RevivalProgressRenderer.java"
      provides: "World-space progress bar above downed players"
      exports: ["render"]
  key_links:
    - from: "DreadDeathManager"
      to: "ServerTickEvents.END_WORLD_TICK"
      via: "tick event registration"
      pattern: "END_WORLD_TICK\\.register"
    - from: "RevivalInteractionHandler"
      to: "player.isSneaking()"
      via: "crouch detection"
      pattern: "isSneaking\\(\\)"
    - from: "DreadDeathManager"
      to: "GameMode.SPECTATOR"
      via: "spectator transition"
      pattern: "changeGameMode.*SPECTATOR"
---

<objective>
Implement revival mechanics (crouch to revive), downed timer processing with spectator transition, crawl movement restrictions, and visual progress bar for revivals.

Purpose: Complete the death/revival loop where teammates can revive downed players, solo players face permanent stakes, and timer expiration leads to spectator mode.

Output:
- Crouch-to-revive within 4 blocks range
- 3-second uninterruptible revival
- Progress bar above downed player (visible to reviver and downed player)
- Timer countdown with spectator transition on expiration
- Crawl movement speed reduction for downed players
- Death message in chat when player becomes spectator
</objective>

<execution_context>
@C:\Users\dylan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dylan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-death-revival-system/03-RESEARCH.md
@.planning/phases/03-death-revival-system/03-CONTEXT.md

# Dependencies
@.planning/phases/03-death-revival-system/03-03-SUMMARY.md
@.planning/phases/03-death-revival-system/03-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DreadDeathManager and RevivalInteractionHandler</name>
  <files>
    src/main/java/com/dread/death/DreadDeathManager.java
    src/main/java/com/dread/death/RevivalInteractionHandler.java
    src/main/java/com/dread/DreadMod.java
  </files>
  <action>
    1. Create RevivalInteractionHandler.java - proximity-based revival detection:
       ```java
       package com.dread.death;

       import com.dread.network.packets.RemoveDownedEffectsS2C;
       import com.dread.network.packets.RevivalProgressS2C;
       import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
       import net.minecraft.entity.attribute.EntityAttributeInstance;
       import net.minecraft.entity.attribute.EntityAttributeModifier;
       import net.minecraft.entity.attribute.EntityAttributes;
       import net.minecraft.server.network.ServerPlayerEntity;
       import net.minecraft.server.world.ServerWorld;
       import net.minecraft.text.Text;
       import net.minecraft.util.Formatting;
       import net.minecraft.util.Identifier;
       import net.minecraft.world.GameMode;

       import java.util.List;
       import java.util.UUID;

       /**
        * Handles proximity-based revival mechanics.
        * Revival is triggered by crouching within 4 blocks of a downed player.
        */
       public class RevivalInteractionHandler {

           private static final double REVIVAL_RANGE = 4.0;  // blocks
           private static final Identifier DOWNED_SPEED_ID =
               Identifier.of("dread", "downed_crawl_speed");

           /**
            * Check for nearby crouching players to initiate revival.
            */
           public static void checkForRevivers(ServerWorld world, DownedPlayersState state) {
               for (DownedPlayerData downed : state.getAllDowned()) {
                   // Skip if already being revived
                   if (state.isBeingRevived(downed.playerId)) {
                       continue;
                   }

                   ServerPlayerEntity downedPlayer = world.getServer()
                       .getPlayerManager().getPlayer(downed.playerId);
                   if (downedPlayer == null) continue;

                   // Find nearby crouching players
                   List<ServerPlayerEntity> nearbyRevivers = world.getPlayers(player ->
                       player != downedPlayer &&
                       !state.isDowned(player) &&
                       player.isSneaking() &&
                       player.squaredDistanceTo(downedPlayer) <= REVIVAL_RANGE * REVIVAL_RANGE
                   );

                   if (!nearbyRevivers.isEmpty()) {
                       // Start revival with closest player
                       ServerPlayerEntity reviver = nearbyRevivers.get(0);
                       startRevival(state, downedPlayer, reviver, world);
                   }
               }
           }

           /**
            * Start uninterruptible 3-second revival.
            */
           private static void startRevival(
               DownedPlayersState state,
               ServerPlayerEntity downed,
               ServerPlayerEntity reviver,
               ServerWorld world
           ) {
               state.startRevival(downed.getUuid(), reviver.getUuid());

               // Send initial progress update to nearby players
               broadcastRevivalProgress(world, downed, 0.0f, true);
           }

           /**
            * Complete a revival - restore player to normal state.
            */
           public static void completeRevival(
               ServerWorld world,
               DownedPlayersState state,
               UUID downedPlayerId
           ) {
               ServerPlayerEntity player = world.getServer()
                   .getPlayerManager().getPlayer(downedPlayerId);
               if (player == null) {
                   state.removeDowned(downedPlayerId);
                   return;
               }

               // Remove from downed state
               state.removeDowned(downedPlayerId);

               // Restore health to half
               player.setHealth(player.getMaxHealth() / 2.0f);

               // Remove movement speed penalty
               removeMovementPenalty(player);

               // Send effect removal to client
               ServerPlayNetworking.send(player, new RemoveDownedEffectsS2C());

               // Send final progress (complete) to nearby players
               broadcastRevivalProgress(world, player, 1.0f, false);

               // Broadcast revival message
               world.getServer().getPlayerManager().broadcast(
                   Text.literal(player.getName().getString() + " has been revived!")
                       .formatted(Formatting.GREEN),
                   false
               );
           }

           /**
            * Apply movement speed penalty to downed player (crawl speed).
            */
           public static void applyMovementPenalty(ServerPlayerEntity player) {
               EntityAttributeInstance speedAttr = player.getAttributeInstance(EntityAttributes.GENERIC_MOVEMENT_SPEED);
               if (speedAttr != null) {
                   // Remove any existing modifier first
                   speedAttr.removeModifier(DOWNED_SPEED_ID);

                   // Apply -90% movement speed (crawl)
                   EntityAttributeModifier modifier = new EntityAttributeModifier(
                       DOWNED_SPEED_ID,
                       -0.9,
                       EntityAttributeModifier.Operation.ADD_MULTIPLIED_TOTAL
                   );
                   speedAttr.addPersistentModifier(modifier);
               }
           }

           /**
            * Remove movement speed penalty on revival.
            */
           public static void removeMovementPenalty(ServerPlayerEntity player) {
               EntityAttributeInstance speedAttr = player.getAttributeInstance(EntityAttributes.GENERIC_MOVEMENT_SPEED);
               if (speedAttr != null) {
                   speedAttr.removeModifier(DOWNED_SPEED_ID);
               }
           }

           /**
            * Broadcast revival progress to all nearby players.
            */
           private static void broadcastRevivalProgress(
               ServerWorld world,
               ServerPlayerEntity downed,
               float progress,
               boolean active
           ) {
               List<ServerPlayerEntity> nearbyPlayers = world.getPlayers(p ->
                   p.squaredDistanceTo(downed) <= 256  // 16 blocks squared
               );

               for (ServerPlayerEntity player : nearbyPlayers) {
                   ServerPlayNetworking.send(player, new RevivalProgressS2C(
                       downed.getUuid(),
                       active,
                       progress
                   ));
               }
           }
       }
       ```

    2. Create DreadDeathManager.java - central tick processor:
       ```java
       package com.dread.death;

       import com.dread.network.packets.DownedStateUpdateS2C;
       import com.dread.network.packets.RemoveDownedEffectsS2C;
       import com.dread.network.packets.RevivalProgressS2C;
       import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents;
       import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
       import net.minecraft.server.network.ServerPlayerEntity;
       import net.minecraft.server.world.ServerWorld;
       import net.minecraft.text.Text;
       import net.minecraft.util.Formatting;
       import net.minecraft.world.GameMode;

       import java.util.ArrayList;
       import java.util.Iterator;
       import java.util.List;
       import java.util.UUID;

       /**
        * Central manager for death/revival system.
        * Processes downed player timers, revival progress, and spectator transitions.
        */
       public class DreadDeathManager {

           // Tick counter for periodic state sync (every 20 ticks = 1 second)
           private static int syncCounter = 0;

           public static void register() {
               ServerTickEvents.END_WORLD_TICK.register(DreadDeathManager::tick);
           }

           private static void tick(ServerWorld world) {
               DownedPlayersState state = DownedPlayersState.getOrCreate(world);

               // Process downed player timers
               processDownedTimers(world, state);

               // Check for revival opportunities
               RevivalInteractionHandler.checkForRevivers(world, state);

               // Process active revivals
               processActiveRevivals(world, state);

               // Periodic state sync
               syncCounter++;
               if (syncCounter >= 20) {
                   syncCounter = 0;
                   syncDownedStates(world, state);
               }
           }

           /**
            * Decrement timers for all downed players.
            * Transition to spectator if timer expires.
            */
           private static void processDownedTimers(ServerWorld world, DownedPlayersState state) {
               List<UUID> expiredPlayers = new ArrayList<>();

               for (DownedPlayerData downed : state.getAllDowned()) {
                   int remainingSeconds = state.decrementTimer(downed.playerId);

                   if (remainingSeconds <= 0) {
                       expiredPlayers.add(downed.playerId);
                   }
               }

               // Handle expired players (transition to spectator)
               for (UUID playerId : expiredPlayers) {
                   transitionToSpectator(world, state, playerId);
               }
           }

           /**
            * Process ongoing revival attempts.
            */
           private static void processActiveRevivals(ServerWorld world, DownedPlayersState state) {
               List<UUID> completedRevivals = state.tickRevivals();

               // Complete successful revivals
               for (UUID downedPlayerId : completedRevivals) {
                   RevivalInteractionHandler.completeRevival(world, state, downedPlayerId);
               }

               // Send progress updates for active revivals
               for (DownedPlayerData downed : state.getAllDowned()) {
                   if (state.isBeingRevived(downed.playerId)) {
                       RevivalProgress progress = state.getRevivalProgress(downed.playerId);
                       if (progress != null) {
                           ServerPlayerEntity downedPlayer = world.getServer()
                               .getPlayerManager().getPlayer(downed.playerId);
                           if (downedPlayer != null) {
                               // Broadcast progress to nearby players
                               for (ServerPlayerEntity nearby : world.getPlayers(p ->
                                   p.squaredDistanceTo(downedPlayer) <= 256)) {
                                   ServerPlayNetworking.send(nearby, new RevivalProgressS2C(
                                       downed.playerId,
                                       true,
                                       progress.getProgress()
                                   ));
                               }
                           }
                       }
                   }
               }
           }

           /**
            * Transition expired player to spectator mode.
            */
           private static void transitionToSpectator(
               ServerWorld world,
               DownedPlayersState state,
               UUID playerId
           ) {
               ServerPlayerEntity player = world.getServer()
                   .getPlayerManager().getPlayer(playerId);

               // Remove from downed state
               state.removeDowned(playerId);

               if (player == null) return;

               // Remove movement penalty
               RevivalInteractionHandler.removeMovementPenalty(player);

               // Send effect removal
               ServerPlayNetworking.send(player, new RemoveDownedEffectsS2C());

               // Change to spectator mode
               player.changeGameMode(GameMode.SPECTATOR);

               // Broadcast death message
               world.getServer().getPlayerManager().broadcast(
                   Text.literal(player.getName().getString() + " has been claimed by the Dread")
                       .formatted(Formatting.DARK_RED),
                   false
               );
           }

           /**
            * Sync downed state to clients (every second).
            */
           private static void syncDownedStates(ServerWorld world, DownedPlayersState state) {
               for (DownedPlayerData downed : state.getAllDowned()) {
                   ServerPlayerEntity player = world.getServer()
                       .getPlayerManager().getPlayer(downed.playerId);
                   if (player != null) {
                       ServerPlayNetworking.send(player, new DownedStateUpdateS2C(
                           true,
                           downed.getRemainingSeconds()
                       ));
                   }
               }
           }
       }
       ```

    3. Update DreadMod.java to register DreadDeathManager:
       ```java
       // In onInitialize(), after DreadDeathHandler.register():
       DreadDeathManager.register();
       ```

    4. Update DreadDeathHandler.java to apply movement penalty when downed:
       Add after state.setDowned(player):
       ```java
       // Apply movement speed penalty (crawl speed)
       RevivalInteractionHandler.applyMovementPenalty(player);
       ```
  </action>
  <verify>
    Run `./gradlew build` to verify compilation.
    Verify DreadMod.java calls DreadDeathManager.register().
  </verify>
  <done>
    - DreadDeathManager ticks every server tick, processing timers and revivals
    - RevivalInteractionHandler detects crouching players for revival
    - 3-second uninterruptible revival mechanic
    - Spectator transition on timer expiration
    - Movement speed penalty applied to downed players
    - State synced to clients every second
  </done>
</task>

<task type="auto">
  <name>Task 2: Create client-side revival progress renderer</name>
  <files>
    src/client/java/com/dread/client/RevivalProgressRenderer.java
    src/client/java/com/dread/DreadClient.java
  </files>
  <action>
    1. Create RevivalProgressRenderer.java - world-space progress bar:
       ```java
       package com.dread.client;

       import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
       import net.minecraft.client.MinecraftClient;
       import net.minecraft.client.font.TextRenderer;
       import net.minecraft.client.render.*;
       import net.minecraft.client.util.math.MatrixStack;
       import net.minecraft.entity.player.PlayerEntity;
       import net.minecraft.util.math.RotationAxis;
       import net.minecraft.util.math.Vec3d;
       import org.joml.Matrix4f;

       import java.util.HashMap;
       import java.util.Map;
       import java.util.UUID;

       /**
        * Renders revival progress bars above downed players in world space.
        */
       public class RevivalProgressRenderer {

           // Track active revivals received from server
           private static final Map<UUID, RevivalData> activeRevivals = new HashMap<>();

           public static void register() {
               WorldRenderEvents.AFTER_ENTITIES.register(context -> {
                   renderActiveRevivals(context);
               });
           }

           /**
            * Update revival progress for a player (called from packet receiver).
            */
           public static void updateRevivalProgress(UUID downedPlayerId, boolean active, float progress) {
               if (active) {
                   activeRevivals.put(downedPlayerId, new RevivalData(progress, System.currentTimeMillis()));
               } else {
                   activeRevivals.remove(downedPlayerId);
               }
           }

           /**
            * Render progress bars for all active revivals.
            */
           private static void renderActiveRevivals(WorldRenderContext context) {
               MinecraftClient client = MinecraftClient.getInstance();
               if (client.world == null || client.player == null) return;

               Camera camera = context.camera();
               MatrixStack matrices = context.matrixStack();
               VertexConsumerProvider consumers = context.consumers();

               // Clean up stale entries (older than 2 seconds without update)
               long now = System.currentTimeMillis();
               activeRevivals.entrySet().removeIf(e ->
                   now - e.getValue().lastUpdate > 2000
               );

               for (Map.Entry<UUID, RevivalData> entry : activeRevivals.entrySet()) {
                   UUID playerId = entry.getKey();
                   float progress = entry.getValue().progress;

                   // Find player entity
                   PlayerEntity downedPlayer = client.world.getPlayerByUuid(playerId);
                   if (downedPlayer == null) continue;

                   // Calculate world position (above player head)
                   Vec3d playerPos = downedPlayer.getPos().add(0, downedPlayer.getHeight() + 0.5, 0);
                   Vec3d cameraPos = camera.getPos();

                   // Distance check (only render within 16 blocks)
                   if (playerPos.squaredDistanceTo(cameraPos) > 256) continue;

                   matrices.push();

                   // Translate to world position relative to camera
                   matrices.translate(
                       playerPos.x - cameraPos.x,
                       playerPos.y - cameraPos.y,
                       playerPos.z - cameraPos.z
                   );

                   // Billboard effect - face camera
                   matrices.multiply(RotationAxis.POSITIVE_Y.rotationDegrees(-camera.getYaw()));
                   matrices.multiply(RotationAxis.POSITIVE_X.rotationDegrees(camera.getPitch()));

                   // Scale down (world units to pixels)
                   float scale = 0.025f;
                   matrices.scale(-scale, -scale, scale);

                   // Render progress bar
                   renderProgressBar(context, matrices, consumers, progress);

                   matrices.pop();
               }
           }

           /**
            * Render a single progress bar.
            */
           private static void renderProgressBar(
               WorldRenderContext context,
               MatrixStack matrices,
               VertexConsumerProvider consumers,
               float progress
           ) {
               int barWidth = 40;
               int barHeight = 6;
               int halfWidth = barWidth / 2;

               Matrix4f matrix = matrices.peek().getPositionMatrix();

               // Get buffer for quad rendering
               VertexConsumer buffer = consumers.getBuffer(RenderLayer.getGui());

               // Background (dark gray)
               drawQuad(buffer, matrix, -halfWidth, -barHeight/2, halfWidth, barHeight/2, 0x80000000);

               // Progress fill (green)
               int fillWidth = (int)(barWidth * progress);
               if (fillWidth > 0) {
                   drawQuad(buffer, matrix, -halfWidth, -barHeight/2, -halfWidth + fillWidth, barHeight/2, 0xFF00FF00);
               }

               // Border (white)
               float borderAlpha = 0.8f;
               // Top
               drawQuad(buffer, matrix, -halfWidth-1, -barHeight/2-1, halfWidth+1, -barHeight/2, 0xCCFFFFFF);
               // Bottom
               drawQuad(buffer, matrix, -halfWidth-1, barHeight/2, halfWidth+1, barHeight/2+1, 0xCCFFFFFF);
               // Left
               drawQuad(buffer, matrix, -halfWidth-1, -barHeight/2, -halfWidth, barHeight/2, 0xCCFFFFFF);
               // Right
               drawQuad(buffer, matrix, halfWidth, -barHeight/2, halfWidth+1, barHeight/2, 0xCCFFFFFF);
           }

           /**
            * Draw a colored quad.
            */
           private static void drawQuad(
               VertexConsumer buffer,
               Matrix4f matrix,
               float x1, float y1,
               float x2, float y2,
               int color
           ) {
               float a = ((color >> 24) & 0xFF) / 255.0f;
               float r = ((color >> 16) & 0xFF) / 255.0f;
               float g = ((color >> 8) & 0xFF) / 255.0f;
               float b = (color & 0xFF) / 255.0f;

               buffer.vertex(matrix, x1, y1, 0).color(r, g, b, a);
               buffer.vertex(matrix, x1, y2, 0).color(r, g, b, a);
               buffer.vertex(matrix, x2, y2, 0).color(r, g, b, a);
               buffer.vertex(matrix, x2, y1, 0).color(r, g, b, a);
           }

           private static class RevivalData {
               float progress;
               long lastUpdate;

               RevivalData(float progress, long lastUpdate) {
                   this.progress = progress;
                   this.lastUpdate = lastUpdate;
               }
           }
       }
       ```

    2. Update DreadClient.java packet receiver for RevivalProgressS2C:
       Replace the TODO placeholder:
       ```java
       // RevivalProgressS2C receiver
       ClientPlayNetworking.registerGlobalReceiver(
           RevivalProgressS2C.ID,
           (payload, context) -> {
               context.client().execute(() -> {
                   RevivalProgressRenderer.updateRevivalProgress(
                       payload.downedPlayerUUID(),
                       payload.active(),
                       payload.progress()
                   );
               });
           }
       );
       ```

    3. Register RevivalProgressRenderer in DreadClient.onInitializeClient():
       ```java
       RevivalProgressRenderer.register();
       ```
  </action>
  <verify>
    Run `./gradlew build` to verify compilation.
    Verify world render event is registered.
  </verify>
  <done>
    - RevivalProgressRenderer draws progress bar in world space
    - Billboard effect - bar always faces camera
    - Progress updates received from server packets
    - Stale entries cleaned up automatically
    - Build succeeds
  </done>
</task>

</tasks>

<verification>
1. Run `JAVA_HOME="X:/Vibe Coding/jdk-21.0.6+7" ./gradlew build`
2. Verify all death/revival classes compile
3. Verify DreadDeathManager registered in DreadMod
4. Verify RevivalProgressRenderer registered in DreadClient
5. Verify packet receivers properly connected
</verification>

<success_criteria>
- Crouch within 4 blocks of downed player initiates 3-second revival
- Revival is uninterruptible once started
- Progress bar visible above downed player during revival
- Timer expiration transitions player to spectator mode
- Death message appears in chat
- Solo players cannot self-revive (permanent death stakes)
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-death-revival-system/03-05-SUMMARY.md`
</output>

---
phase: 04-configuration-release-prep
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/client/java/com/dread/client/ShaderCompatibilityDetector.java
  - src/client/java/com/dread/client/DownedStateClientHandler.java
  - src/client/java/com/dread/DreadClient.java
autonomous: true

must_haves:
  truths:
    - "Iris shader mod is detected at runtime without crashing"
    - "Post-processing effects are disabled when Iris is detected"
    - "disableDownedEffects=true forces effects off regardless of shader mods"
    - "Game runs without crash when Iris and Dread are both installed"
  artifacts:
    - path: "src/client/java/com/dread/client/ShaderCompatibilityDetector.java"
      provides: "Runtime shader mod detection"
      exports: ["detect", "shouldDisablePostProcessing"]
    - path: "src/client/java/com/dread/client/DownedStateClientHandler.java"
      provides: "Conditional shader application"
      contains: "ShaderCompatibilityDetector"
  key_links:
    - from: "src/client/java/com/dread/DreadClient.java"
      to: "ShaderCompatibilityDetector.detect()"
      via: "Called during client init"
      pattern: "ShaderCompatibilityDetector\\.detect\\(\\)"
    - from: "src/client/java/com/dread/client/DownedStateClientHandler.java"
      to: "ShaderCompatibilityDetector.shouldDisablePostProcessing()"
      via: "Guard before shader render"
      pattern: "shouldDisablePostProcessing\\(\\)"
---

<objective>
Implement shader mod compatibility detection and graceful fallback.

Purpose: Detect Iris/Optifine at runtime and disable Satin post-processing effects to prevent crashes and visual glitches when shader mods are active.
Output: ShaderCompatibilityDetector utility, modified DownedStateClientHandler with fallback logic, detection call in DreadClient
</objective>

<execution_context>
@C:\Users\dylan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dylan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-configuration-release-prep/04-RESEARCH.md
@.planning/phases/04-configuration-release-prep/04-01-SUMMARY.md
@src/client/java/com/dread/client/DownedStateClientHandler.java
@src/client/java/com/dread/DreadClient.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ShaderCompatibilityDetector</name>
  <files>src/client/java/com/dread/client/ShaderCompatibilityDetector.java</files>
  <action>
Create shader compatibility detection utility:

```java
package com.dread.client;

import com.dread.config.DreadConfigLoader;
import net.fabricmc.loader.api.FabricLoader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Detects shader mods at runtime and determines if post-processing
 * effects should be disabled for compatibility.
 */
public class ShaderCompatibilityDetector {
    private static final Logger LOGGER = LoggerFactory.getLogger("dread-client");

    private static boolean irisDetected = false;
    private static boolean optifineDetected = false;

    /**
     * Detect shader mods at startup.
     * Call once during client initialization.
     */
    public static void detect() {
        // Detect Iris (most common Fabric shader mod)
        irisDetected = FabricLoader.getInstance().isModLoaded("iris");

        // Detect Optifine (less common on Fabric, uses different mod ID)
        // Note: Optifine on Fabric typically uses OptiFabric with mod ID "optifabric"
        optifineDetected = FabricLoader.getInstance().isModLoaded("optifabric")
                        || FabricLoader.getInstance().isModLoaded("optifine");

        if (irisDetected) {
            LOGGER.info("Iris shader mod detected - post-processing fallback enabled");
        }
        if (optifineDetected) {
            LOGGER.info("OptiFine detected - post-processing fallback enabled");
        }
        if (!irisDetected && !optifineDetected) {
            LOGGER.info("No shader mods detected - full post-processing enabled");
        }
    }

    /**
     * Determine if post-processing effects should be disabled.
     *
     * @return true if effects should be disabled, false if safe to apply
     */
    public static boolean shouldDisablePostProcessing() {
        var config = DreadConfigLoader.getConfig();

        // Config override: force disable regardless of shader mods
        if (config.disableDownedEffects) {
            return true;
        }

        // Graceful fallback: disable if shader mods detected
        return irisDetected || optifineDetected;
    }

    /**
     * Check if Iris is specifically detected (for logging/debugging).
     */
    public static boolean isIrisDetected() {
        return irisDetected;
    }

    /**
     * Check if OptiFine is specifically detected (for logging/debugging).
     */
    public static boolean isOptifineDetected() {
        return optifineDetected;
    }
}
```

Key points:
- Uses FabricLoader.isModLoaded() for reliable detection
- Checks both "iris" and "optifabric"/"optifine" mod IDs
- Config override takes precedence (disableDownedEffects=true)
- Logs detection results for debugging
  </action>
  <verify>File compiles: `./gradlew compileJava --console=plain 2>&1 | tail -20`</verify>
  <done>ShaderCompatibilityDetector.java exists with detect() and shouldDisablePostProcessing() methods</done>
</task>

<task type="auto">
  <name>Task 2: Add fallback logic to DownedStateClientHandler</name>
  <files>src/client/java/com/dread/client/DownedStateClientHandler.java</files>
  <action>
Modify DownedStateClientHandler to check shader compatibility before applying effects:

1. In register(), modify the shader render callback to check compatibility:

Find this code:
```java
WorldRenderEvents.AFTER_TRANSLUCENT.register(context -> {
    if (isDownedEffectActive && downedShader != null) {
        downedShader.render(context.tickCounter().getTickDelta(true));
    }
});
```

Replace with:
```java
WorldRenderEvents.AFTER_TRANSLUCENT.register(context -> {
    // Skip shader if compatibility mode or disabled by config
    if (ShaderCompatibilityDetector.shouldDisablePostProcessing()) {
        return;
    }

    if (isDownedEffectActive && downedShader != null) {
        downedShader.render(context.tickCounter().getTickDelta(true));
    }
});
```

2. Also update applyDownedEffects() to log when effects are disabled:
```java
public static void applyDownedEffects(int remainingTime) {
    isDownedEffectActive = true;
    remainingSeconds = remainingTime;

    if (ShaderCompatibilityDetector.shouldDisablePostProcessing()) {
        LOGGER.info("Applied downed state ({}s remaining) - shader effects disabled for compatibility", remainingTime);
    } else {
        LOGGER.info("Applied downed state effects ({}s remaining)", remainingTime);
    }
}
```

The HUD timer still appears (DownedHudOverlay is not affected by shader compatibility).
Only the blur/vignette post-processing is disabled.
  </action>
  <verify>File compiles: `./gradlew compileJava --console=plain 2>&1 | tail -20`</verify>
  <done>DownedStateClientHandler checks ShaderCompatibilityDetector before rendering shader effects</done>
</task>

<task type="auto">
  <name>Task 3: Initialize detection in DreadClient</name>
  <files>src/client/java/com/dread/DreadClient.java</files>
  <action>
Call shader detection during client initialization:

1. Add import: `import com.dread.client.ShaderCompatibilityDetector;`

2. In onInitializeClient(), add detection call BEFORE registering downed state handlers:
```java
@Override
public void onInitializeClient() {
    LOGGER.info("Initializing Dread client...");

    // Detect shader mods for compatibility (before downed state handler)
    ShaderCompatibilityDetector.detect();

    // Register Dread entity renderer with GeckoLib
    EntityRendererRegistry.register(ModEntities.DREAD, DreadEntityRenderer::new);
    LOGGER.info("Registered DreadEntityRenderer with AutoGlowingGeoLayer");

    // ... rest of existing initialization
}
```

Detection must happen before DownedStateClientHandler.register() so the compatibility flag is set when the render callback is registered.
  </action>
  <verify>Build succeeds: `./gradlew build --console=plain 2>&1 | tail -30`</verify>
  <done>DreadClient.onInitializeClient() calls ShaderCompatibilityDetector.detect() before DownedStateClientHandler.register()</done>
</task>

</tasks>

<verification>
1. Build compiles successfully: `./gradlew build`
2. ShaderCompatibilityDetector exists with detect() and shouldDisablePostProcessing()
3. DownedStateClientHandler checks shouldDisablePostProcessing() before rendering
4. DreadClient calls ShaderCompatibilityDetector.detect() during init
</verification>

<success_criteria>
- ShaderCompatibilityDetector detects Iris via FabricLoader.isModLoaded("iris")
- ShaderCompatibilityDetector detects OptiFine via FabricLoader.isModLoaded("optifabric")
- shouldDisablePostProcessing() returns true when config.disableDownedEffects=true
- shouldDisablePostProcessing() returns true when Iris or OptiFine detected
- DownedStateClientHandler skips shader render when shouldDisablePostProcessing()=true
- HUD countdown timer still displays (only shader effects disabled, not HUD)
- Build succeeds with no compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-configuration-release-prep/04-03-SUMMARY.md`
</output>

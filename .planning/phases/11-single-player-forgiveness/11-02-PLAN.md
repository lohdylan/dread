---
phase: 11-single-player-forgiveness
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/main/java/com/dread/death/DreadDeathManager.java
  - src/main/java/com/dread/death/DownedPlayersState.java
autonomous: true

must_haves:
  truths:
    - "Single-player timer expiration triggers full death cinematic then normal death"
    - "Multiplayer timer expiration still transitions to permanent spectator mode"
    - "Normal death respects keepInventory gamerule"
    - "Player can respawn at bed or world spawn after singleplayer death"
  artifacts:
    - path: "src/main/java/com/dread/death/DreadDeathManager.java"
      provides: "Mode-branched death handling"
      contains: "triggerSingleplayerDeath"
    - path: "src/main/java/com/dread/death/DownedPlayersState.java"
      provides: "Dread death tracking for respawn debuff"
      contains: "markDreadDeath"
  key_links:
    - from: "src/main/java/com/dread/death/DreadDeathManager.java"
      to: "DownedPlayerData.mode"
      via: "mode check in processDownedTimers"
      pattern: "data\\.mode == DreadGameMode\\.SINGLEPLAYER"
---

<objective>
Implement death outcome branching based on game mode - normal death for singleplayer, spectator for multiplayer.

Purpose: When downed timer expires in singleplayer, trigger full death cinematic followed by normal Minecraft death (respawn at bed/spawn). Multiplayer retains hardcore permanent spectator behavior.

Output: Modified DreadDeathManager with mode-aware death branching, triggerSingleplayerDeath method, and Dread death tracking for respawn debuff.
</objective>

<execution_context>
@C:\Users\dylan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dylan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-single-player-forgiveness/11-CONTEXT.md
@.planning/phases/11-single-player-forgiveness/11-RESEARCH.md

Key existing files:
@src/main/java/com/dread/death/DreadDeathManager.java
@src/main/java/com/dread/death/DownedPlayersState.java
@src/main/java/com/dread/death/DeathCinematicController.java
@src/main/java/com/dread/entity/DreadEntity.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Dread death tracking to DownedPlayersState</name>
  <files>src/main/java/com/dread/death/DownedPlayersState.java</files>
  <action>
Add transient tracking for Dread deaths (used to apply respawn debuff):

1. Add a new transient Set field (similar to escapedPlayers):
   private final transient Set<UUID> recentDreadDeaths = new HashSet<>();

2. Add method to mark player for respawn debuff:
   public void markDreadDeath(UUID playerId) {
       recentDreadDeaths.add(playerId);
       // Note: Do NOT call markDirty() - this is transient data
   }

3. Add method to check if player died from Dread:
   public boolean hadRecentDreadDeath(UUID playerId) {
       return recentDreadDeaths.contains(playerId);
   }

4. Add method to clear the flag after applying debuff:
   public void clearDreadDeathFlag(UUID playerId) {
       recentDreadDeaths.remove(playerId);
   }

NOTE: This is transient (not persisted) intentionally - if server restarts, the debuff penalty is skipped. This matches the existing escapedPlayers pattern.
  </action>
  <verify>
File compiles without errors:
```bash
export JAVA_HOME="X:/Vibe Coding/jdk-21.0.6+7" && cd "X:/Vibe Coding" && ./gradlew classes --quiet
```
  </verify>
  <done>DownedPlayersState has markDreadDeath(), hadRecentDreadDeath(), and clearDreadDeathFlag() methods for tracking singleplayer Dread deaths</done>
</task>

<task type="auto">
  <name>Task 2: Implement mode-branched death handling in DreadDeathManager</name>
  <files>src/main/java/com/dread/death/DreadDeathManager.java</files>
  <action>
Modify processDownedTimers() to branch on game mode and add singleplayer death method:

1. Add imports at top:
   - import com.dread.death.GameModeDetector.DreadGameMode;
   - import com.dread.entity.DreadEntity;
   - import com.dread.config.DreadConfigLoader;
   - import java.util.Comparator;
   - import java.util.List;

2. Modify the expiration handling section in processDownedTimers():
   Replace the simple transitionToSpectator call with mode-based branching:

   for (UUID playerId : expiredPlayers) {
       DownedPlayerData data = state.getDownedData(playerId);
       if (data != null && data.mode == DreadGameMode.SINGLEPLAYER) {
           triggerSingleplayerDeath(world, playerId, state);
       } else {
           transitionToSpectator(world, playerId, state);
       }
   }

3. Add new method triggerSingleplayerDeath():
   private static void triggerSingleplayerDeath(ServerWorld world, UUID playerId, DownedPlayersState state) {
       ServerPlayerEntity player = world.getServer().getPlayerManager().getPlayer(playerId);
       if (player == null) {
           state.removeDowned(playerId);
           return;
       }

       // Trigger death cinematic first (if not skipped in config)
       DreadEntity dread = findNearestDread(player, 32.0);
       if (dread != null && !DreadConfigLoader.getConfig().skipDeathCinematic) {
           DeathCinematicController.triggerDeathCinematic(player, dread);
       }

       // Exit crawl pose BEFORE death
       CrawlPoseHandler.exitCrawlPose(player);

       // Remove movement penalty
       RevivalInteractionHandler.removeMovementPenalty(player);

       // Mark for respawn debuff
       state.markDreadDeath(playerId);

       // Remove from downed state
       state.removeDowned(playerId);

       // Broadcast death message (same as multiplayer)
       Text deathMessage = Text.literal(player.getName().getString() + " succumbed to the Dread");
       world.getServer().getPlayerManager().broadcast(deathMessage, false);

       // Trigger normal Minecraft death - respects keepInventory, shows death screen
       player.kill();
   }

4. Add helper method findNearestDread() (copy from DreadDeathHandler or add new):
   private static DreadEntity findNearestDread(ServerPlayerEntity player, double range) {
       List<DreadEntity> dreads = player.getServerWorld().getEntitiesByClass(
           DreadEntity.class,
           player.getBoundingBox().expand(range),
           dread -> true
       );

       if (dreads.isEmpty()) {
           return null;
       }

       return dreads.stream()
           .min(Comparator.comparingDouble(dread -> dread.squaredDistanceTo(player)))
           .orElse(null);
   }

IMPORTANT:
- Import RevivalInteractionHandler if not already imported
- Import DeathCinematicController
- The death message uses same text as multiplayer for consistency
  </action>
  <verify>
Build succeeds:
```bash
export JAVA_HOME="X:/Vibe Coding/jdk-21.0.6+7" && cd "X:/Vibe Coding" && ./gradlew classes --quiet
```
  </verify>
  <done>DreadDeathManager branches on mode - SINGLEPLAYER triggers cinematic + player.kill(), MULTIPLAYER transitions to spectator</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build succeeds: `./gradlew build`
2. Singleplayer downed expiration triggers cinematic + normal death
3. Multiplayer downed expiration still transitions to spectator
4. Death message broadcasts in both modes
5. Dread death flag is set for respawn debuff tracking
</verification>

<success_criteria>
- triggerSingleplayerDeath() method exists and triggers cinematic + player.kill()
- processDownedTimers() checks data.mode and routes to appropriate handler
- DownedPlayersState tracks Dread deaths for respawn debuff
- Build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/11-single-player-forgiveness/11-02-SUMMARY.md`
</output>
